const isPlainValue = v => ([ 'string', 'number', 'boolean' ].includes(typeof v));const wasChanged = (v1, v2) => (v1 !== v2);export function set(Store) {  return object => {    Object.keys(object).forEach(key => {      const previousValue = Store.objects.observables[key];      const previousValueClone = Array.isArray(previousValue)        ? [ ...previousValue ]        : typeof previousValue === 'object'          ? { ...previousValue }          : previousValue;      const nextValue = typeof object[key] === 'function'        ? object[key](previousValueClone)        : object[key];      console.log("key", key);      console.log("previousValue", previousValue);      console.log("typeof previousValue", typeof previousValue);      console.log("nextValue", nextValue);      console.log("typeof nextValue", typeof nextValue);      if (typeof previousValue !== typeof nextValue) {        console.warn(`Type does not match previous type in ${key}`);      } else {        const shouldNotify = !isPlainValue(nextValue) ||          (isPlainValue(nextValue) && wasChanged(previousValue, nextValue));        if (shouldNotify) {          Store.objects.observables[key] = object[key];          Store.methods.notify(key);        }      }    });  };}